

-- MySQL 的索引事务：都属于 MySQL 原理层面的东西，比较抽象的，离咱们比较遥远
-- 面试要考，尤其是考索引事务。
-- MySQL 索引的情况：相当于一本书的目录。也就是在数据库当中查找的时候，按照一定的条件来查找
-- 查找可以遍历表，但是遍历表操作比较低效。所以要想办法避免遍历，通过特殊的数据结构来记录特征，
--      通过特征来比较次数，加快比较的效率
-- 索引的主要意义就是进行查找，提高查找效率。查找效率提高了，但是同时也会付出代价
--      数据库的索引，也是需要小号一些额外存储空间的，数据量越大，消耗的额外空间就越多。
--      索引确定之后，后续每次对内容进行增删改的时候，往往也需要同步的调整索引的结构
-- 索引带来的好处：提高了查找速度
-- 索引带来的坏处：占用更多空间，拖慢了增删改的速度。
--      因为查找是最高频的操作，所以还是要用到索引。

-- 有了索引之后，对查找的提升是非常大的。循环是在纯内存当中的比较。MySQL 是比较在硬盘上的
--      因为硬盘的 IO 速度比 内存 的速度慢很多，索引会提升上万倍。访问磁盘 IO 会很慢

-- 查看索引：show index from 表名;
-- 直接查看 student 表，发现里面已经自带了一个索引，这个自带的索引就是 primary 这个主键约束来的
show index from student;
-- 查询的时候，如果指定了根据主键来查询，这个时候查询就会非常快。unique 也自带索引

-- 给一个表中的某个列来创建索引 create index 索引名字 on 表名(列名);
-- 创建索引是一个非常低效的事情，尤其是表里面已经有很多数据的时候
-- 针对线上的数据库，如果表没有索引，就不要贸然取创建索引。不然就会挂。
-- 在公司操作数据库，一定一定一定要非常小心
create index name_index on student(name);

-- 删除索引：drop index 索引名字 on 表名;
-- 删除索引的时候，也可能导致数据库挂掉。
-- 创建，删除索引，应该在数据库刚开始就调整
drop index name_index on student;

-- SQL 主要就是使用增删改查，也支持条件，循环，变量，函数等这些编程语言普遍的机制，但是这些操作很少用到。
-- 使用这些逻辑的时候，一般搭配 Java 来使用

-- 面试中考察的主要是 ”索引背后的数据结构“
--      索引，数据结构需要能够加快查找（按照 值 来查找，不是按照 下标）的速度：二叉树 AVL树 红黑树 哈希表

-- 二叉搜索树：查找时间复杂度是：O(N)，最坏情况就是变成单枝树。所以不要让 二叉搜索树变成单枝树
-- AVL：要求任意节点左右子树高度不超过 1
-- 红黑树：要求更宽松的平衡二叉树
-- 二叉树最大的问题：元素多了的时候，高度就够了，比较次数就多了，对于数据库来说，每次比较都意味着磁盘 IO

-- 哈希表 也不太适合索引：因为查找速度很快，但是不能对 大于小于，一集范围查找进行判定

-- 堆也更不行：只能找最大和最小

-- 最适合做索引的，还得是 树形结构，不过不是二叉树。使用多叉搜索树，高度就下降了，速度就快了

-- 在数据库当中使用的 多叉搜索树 又不一样，是一个很特殊的 B+树 （数据库索引当作最常见的数据结构）
-- 每个数据库底层又支持多种存储引擎（实现了数据具体按照啥结构来存储的程序）
-- 要想理解 B+树 先了解前身 B树（有的地方写的 B-树，不是减，是连接符）
-- B+树 就是为数据库量身定做的
-- 使用 B+树 进行查找的时候，整体的 IO 次数也是比较少的
-- 索引的查询结果最终都会落到叶子节点上，每次查询的 IO 次数都是差不多的，查询速度稳定
-- 叶子结点用链表连接之后，非常适合进行范围查找，例如：找到 >=5<=11 的值
-- 所有的数据存储（载荷），都是放到叶子节点上的，非叶子结点只保存 key 值即可，一次非叶子节点整体占用的空间较小，
--      甚至可以缓存到内存中。一旦能够放到内存里，这个时候，内存 IO 几乎就没了。
-- 整个数据库保存的就是载荷（payload）
-- 面试题：谈谈那你对索引的理解：
--      1、索引是干啥的
--      2、索引的适用场景，付出的代价
--      3、索引背后的数据结构：B+树（比较推荐的做法，直接给面试官画一个 B+ 树）
--      4、千万不要背书，而是通过：举例+画图 来回答。博客也很重要。

-- 事务：事务诞生的目的就是为了吧若干个独立的操作给打包成一个整体。
--      要么就是把两个操作都执行完，要么就是一个操作都不执行。不存在执行一个就不执行第二个了。
-- 有的复杂任务需要多个 SQL 来执行，有的时候，也同样需要打包在一起。前一个 SQL 是为了给另外一个 SQL 打基础
-- 如果后一个 SQL 不执行了或者执行出问题了，前一个 SQL 也就失去意义了。
-- 原子性：要么全部执行完，要么一个都不执行，任务不可以被细分了。
-- 举例：转账：A 给 B 转账 500 ，账户表，一个是名字，一个是余额。给 A 余额减 500 给 B 加 500
-- update 账户表 set balance = balance - 500 where name = 'A'   给 A 账户余额 - 500
-- update 账户表 set balance = balance + 500 where name = 'B'   给 B 账户余额 + 500

-- 考虑一个极端情况：执行完第一个 SQL 之后，在执行第二个 SQL 之前，发现意外了 程序崩了 数据库挂了
-- 所以事务的原子性，就能避免出现这样的中间状态。要么就全部执行成功，要么就一个都不执行
-- 因为无法预知执行成功或失败，所以还是要先执行第一个 SQL 然后再执行第二个 SQL
-- 如果执行失败的话，数据库就进行还原的操作。看起来就好像没执行。就是回滚（rollback）

-- 执行第二个 SQL 的时候出现了意外，导致无法执行，那么接下来数据库就会还原之前的操做
-- 数据库会有记录：整个记录过程搭配了日志+数据库内置的一些表来完成。会消耗大量的时间和空间
-- 所以记录不会保存太久

-- 数据库的备份是为了应对突发情况：硬盘坏了（概率挺高，最容易坏）。
-- cpu 很难用坏    机械硬盘很容易坏

-- 使用事务的时候，先来一个 start transaction  然后执行多条 SQL 语句，回归并提交 rollback/commit

--事务相关的面试题：谈谈事务的基本特性。四个特性：
-- 1、原子性
-- 2、一致性：事务执行前后数据库中的数据都得是合理合法的。就像转账之后余额不能出现负数
-- 3、持久性：事务一旦提交之后，数据就写入硬盘存储起来了
-- 4、隔离性（关键，重要）：描述的是书屋并发执行时候，产生的情况！！！
--      并发执行：写出来的代码是并发执行的。一心两用  计算机擅长并发
--      当并发执行多个事务，尤其是这多个事务在尝试修过/读取同一份数据。这个时候就容易出现一些问题：
--         事务的隔离性，就是解决上述问题
-- 举例：在写代码，写了 student 类，写了 name   id 属性，在写代码的过程中。有人把代码改了一下。
--      但是我最后还会修改数据，这里修改的只是中间过程的数据。中间过程的数据可能会被改成别的值。
--      这就是 ”脏读问题“ 。这个数据很可能就是一个脏数据（数据是一个临时结果，不是最终结果）
--      脏读的原因就是事务和事务之间，没有任何的隔离，通过加上一些约束限制，就可以有效避免脏读问题
-- 举例：就像多人协作填表的时候，也是一个数据的过程，并不是最终结果。

-- 如何避免脏读：给写操作加锁。在修改的过程当中别人就不能读了（加锁的状态），等修改完之后，别人才能读（接触加锁）
-- 一旦加了这个写锁之后，意味着事务之间的隔离性就高了，并发性就降低了
-- 一个事务中，包括了多次的读操作，在读的时候在写入，就导致了最后一次读之前写完了，就导致和前几次读到的内容不一样了
--      也就是不可重复读。

-- 上面这个例子就可以再做一个约定：修改的时候不能读，读的时候不能修改。就是给读操作加锁。
-- 给读操作加锁之后，并发性降低了，隔离性就提高了。隔离性降低，并发性提高，运行就快了。
--      并发性和隔离性是二者不可得兼的。跑得快 还是 跑的对，就要取舍了。
-- 并发就是一起编写表格，隔离就是一个一个来。前者快，后者安全。不过也可以调整每次多少人来填表

-- 还有一种情况
-- 在读的过程当中，去写另外一个代码，然后提交另外一个。读完前一个的时候，再修改前一个代码然后提交。

-- 事务虽然在提交隔离性的时候要再进行一系列加锁，但是这个锁也不是把整个数据库都给锁定了，
--      还可以修改其它的表，甚至说这个表的其它的行。但是这个事情带来了其他问题。
--      读代码的过程中，发现代码的数量变了，本来有一个 A.java  现在又多了一个 B.java
--      就是 幻读问题 ：一个事务执行过程中进行多次查询，多次查询的结果集不一样（多了一条或者少了一条）
--      这个操作算是一种特殊的，不可重复读。 解决幻读问题：彻底串行化执行。在读代码的时候，就不要写了。
--      隔离程度最高，并发程度最低，数据最可靠，速度最慢。

-- 并发（快）和隔离（准）是不可兼得的。就可以根据不同情况来调整隔离程度。控制事务的隔离性，控制并发程度

-- MySQL 当中，事务的隔离级别，提供了这么几种：
-- 1、read uncommitted 允许读取未提交的数据，并发程度最高，隔离程度最低。会引入 脏读+不可重复读+幻读问题
-- 2、read committed 只允许读取提交之后的数据，相当于写加锁，并发程度降低一些，
--      隔离程度高了一些，解决了脏读，会引入 不可重复读+幻读
-- 3、repeatable read 相当于给 读和写 都加锁，并发程度降低了，隔离程度又提高了，解决了脏读和不可重复读，会引入幻读
-- 4、serializable 串行化，并发程度最低，隔离程度最高，解决了脏读，不可重复读，寒毒问题，但是执行速度最慢
-- 5、就可以通过修改 my.ini 这个配置文件，来设置当前的隔离级别。根据实际的需求场景不同，来决定使用哪种隔离级别

-- 后期学到多线程，就用到并发了
-- 面试问题：面试官问你如何理解事务，其实就是让你回答上述的这些内容。如果一个问题可以给面试官讲半个小时，那么就稳了

-- 锁的力度大小可以修改。


