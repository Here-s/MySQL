

-- 新增
-- insert into 表名 values （列的值，值，..）
-- 还可以插入指定列（不是插入所有的列）
insert into student (id,name) values (10,'Lockey');-- 只插入学生的 id 和 名字。
-- 一条语句插入多条记录：values 后面放多个括号，每个括号对于一条记录（一行）


-- 查询
-- 1、全列查找：select * from 表名；
-- 2、指定列查找：select 列名，列名 from 表名；
-- 3、指定表达式查找：select * 表达式 from 表名;
-- 4、指定别名 select 表达式 as 别名 from 表名;
-- 5、去重：select distinct 列名 from 表名
-- 6、排序：select 列名 from 表名 order by 列名/表名 asc/desc;   也可以指定多个列，优先第一列
-- 7、条件：select 列名 from 表名 where 条件;   数据库服务器会遍历记录，然后带入到条件，符合条件的就输出
--      条件涉及到的运算符： < <= > >= = <=>    is null    is not null   like  between  and  in
-- 8、分页查询：select 列名 from 表名 limit N offset M;  从 M 条记录开始，一共返回 N 个。


-- 修改
-- update 表名 set 列名 = 值，列名 = 值 where 条件；    没有 where 的话，就会全部修改。


-- 删除
-- delete from 表名 where 条件。   如果没有 where 就会清空整张表的数据。一定要保证 where 的条件是正确的


-- MySQL 的约束    数据库对数据本身有一些要求和限制（帮助程序员检查数据是不是不靠谱）
-- 1、NOT NULL 表述数据不能为 NULL
-- 2、UNIQUE 表示数据不能重复，针对列来描述的
-- 3、DEFAULT 默认值
-- 4、PRIMARY KEY 数据的唯一身份标识
-- 5、  外键约束，针对两张表，进行了关联：学生（id，name，classid）    班级（id，name）
--    每个班级都得属于一个具体的班级，这个班级得存在。班级 id 只有 1-100
--    如果学生表这里出现了一个记录，班级 id 是 10000，此时这样的数据是方法的
--    学生表依赖了班级表，就把”学生表“认为子表，”班级表“认为父表

-- 创建表
create table class(classId int primary key auto_increment,name varchar(50));
-- auto_increment 自动增加 id
-- 插入表
insert into class values(null,'计算机一班');

-- 构建一个学生表，使用外键约束
create table student(studentId int primary key auto_increment,name varchar(20),
                    classId int, foreign key (classId) references class(classId));
-- references 是引用的意思，引用父表的名字，表示依赖关系，当前这个表的 classId 就得引用自/依赖于父表
--      class 表的 classId 这一列。 子表中对应的记录得在父表中存在
-- 插入数据
insert into student values (null,'张三',1);-- 因为插入的 id 为 1，在 class 表里面存在 id 所以可以插入

-- 在插入数据之前， mysql 会先拿着 classId 去 class 表里查一下，看看是否存在，存在才能插入成功
insert into student values (null,'李四',100);-- id 超了，所以不能用

insert into student values (null,'李四',1);-- classId 是可以一样的

-- 外键约束对于父表也有约束，当父表中的某条记录被子表依赖的时候，就不能删除父表了。
-- 如果没有被依赖的话，就可以被删除
-- 如果直接 drop 删表的话，也删不了。

-- 外键约束的工作原理，
-- 在子表中插入新的记录的时候，就会先根据对应的值，在父表当作查询，查询到之后，才能执行后续插入。
-- 外键约束要求，父表中被依赖的这一列，必须有索引。这样就能提高查询速度
-- 索引的时候，要有 primary key 和 unique 约束的，这样就能创建出索引了

-- 在删除商品的时候，是把商品逻辑删除，加一个列，值为 1 的时候就显示，值是 0 就不显示，相当于删除了。


-- 表的设计 数据库的设计 就是根据实际问题场景，把表创建出来。
-- 给你一个 问题场景，如何设计数据库，设计表。：先找出场景涉及的实体，然后再来分析”实体之间的关系“
-- 实体：关键性的名词


-- 一个典型的场景：学生管理系统
-- 1、学生的基本信息  2、班级的基本信息  3、课程的基本信息
-- 对于找到的实体来说，要创建对应的表来表示相关的信息。
-- 很多时候，实体与实体之间存在对应关系，这种关系也要体现在表中。实体之间的关系要分析清楚

-- 实体间的关系：
-- 1、一对一的关系
-- 2、一对多的关系
-- 3、多对多的关系
-- 4、不存在关系

-- 分析实体间的关系，就是：小学生造句

-- 1、一对一关系
-- 以”教务系统“为例，
-- student 表：包含了学生的 id 姓名，班级
-- user 表：用户的账户、密码等
-- 造的句子：一个账户对应一个学生，一个学生对应一个账户    一对一的关系
-- 数据库当中表示一对一的关联关系：
--    方法一：把两个实体用一张表来表示
--    方法二：用两张表来表示，其中一张表包含了另一个表的 id。比如说在 学生表当中加入 uesrId
--           用户表当中加入 studentId

-- 2、一对多关系
-- 以”教务系统“为例，
-- student：包含了学生的 id 姓名，班级
-- user 表：用户的账户、密码等
-- 一个学生应该处于一个班级中，一个班级可以包含多个学生
-- 在数据库中表示一对多的关系，也有两种典型的方案：
--      方案一：在班级表中，新增一例，表示这个班级里的学生 id 都有啥
--              student 表（学号，姓名）  class 表（班级编号，班级名称，学生列表）
--              班级编号 1 ：计算机一班，计算机二班   学生列表：1，2，3，4，5
--              班级编号 2 ：计算机三班，计算机四班   学生列表：6，7，8，9，10
--      方法二：班级表不变，在学生表当中，新增一列：classId
--              class 表（班级编号，班级名称）
--              student 表（学号，学生姓名，所在班级） 通过这种方式也能知道一个学生对应到哪个班级

-- 对于 MySQL 来说，表示一对多的时候，只能采用方案二，不能采用方案一。因为 MySQL 当中没有数组这样的类型
-- 像 Redis 数据库就有这样的数组类型

-- 一个列，既可以当主键，又可以当外键

-- 3、多对多的关系
-- 也是固定讨论
-- student 表：学号，班级
-- 课程表：课程编号，课程名字
-- 学生和课程就是多对多的关系
-- 一个学生可以选多个课，一个课包含多个学生。   M 个学生，可以选 N 门课
-- 多对多关系，在数据库设计的时候，只有一个方法：使用一个关联表，来表示两个实体之间的关系
--      学生表（学号，姓名）：1 张三，2 李四，3 王五    课程表（编号，名称）：1 语文，2 数学，3 英语。
--      创建一个关联表：学生-课程表（学号，课程编号）
--          假设是 1，1  意思就是：学号为 1 的学生，选了课程编号为 1 的课程。就是：张三选了语文课


-- 有时候为了更方便找到实体之间的关系（尤其是针对比较复杂的场景）还可以通过画 ER 图的方式来表示
--      学校考 ER 图，必考


-- 和查询结合在一起的新增：把从上一个表中查询的结果，作为写一个表要插入的数据
create table A (id int,name varchar(50));
insert into A values (1, '张三'),(2, '李四'),(3, '王五');

-- 创建另外一张表 B
create table B (id int, name varchar(50));

-- 把 A 的记录插到 B 里面
insert into B select * from A;-- 在这个语句当中，先执行查找，然后针对查到的结果都插入 B 当中
--      我们要保证：从 A 当中查到的数据类型和 B 当中的数据类型一样

-- 重新创建 B
create table B (name varchar(50), id int); -- 这样也能插入到 B ，只要保证 A 的查询结果的列能和 A 对应就好

-- 插入方法：先找出 A 的名字，然后是 id 就可以插入了
insert into B select  name, id from A;
-- insert 改的是硬盘的数据

-- 还可以给后面的 select 指定一些其它的条件：排序，limit，去重











